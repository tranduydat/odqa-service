CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS In Chapter 12, we focused on what an instruction set does. Specifically, we examined the types of operands and operations that may be specified by machine instructions. This chapter turns to the question of how to specify the operands and operations of instructions. Two issues arise. First, how is the address of an operand specified, and second, how are the bits of an instruction organized to define the operand addresses and operation of that instruction? 13.1 ADDRESSING MODES The address field or fields in a typical instruction format are relatively small. We would like to be able to reference a large range of locations in main memory or, for some systems, virtual memory. To achieve this objective, a variety of addressing techniques has been employed. They all involve some trade-off between address range and/or addressing flexibility, on the one hand, and the number of memory references in the instruction and/or the complexity of address calculation, on the other. In this section, we examine the most common addressing techniques, or modes: • Immediate • Direct • Indirect • Register • Register indirect • Displacement • Stack These modes are illustrated in Figure 13.1. In this section, we use the following notation: A = contents of an address field in the instruction R = contents of an address field in the instruction that refers to a register LEARNING OBJECTIVES After studying this chapter, you should be able to: � Describe the various types of addressing modes common in instruction sets. � Present an overview of x86 and ARM addressing modes. � Summarize the issues and trade-offs involved in designing an instruction format. � Present an overview of x86 and ARM instruction formats. � Understand the distinction between machine language and assembly language. 13.1 / ADDRESSING MODES 453 EA = actual (effective) address of the location containing the referenced operand (X) = contents of memory location X or register X Table 13.1 indicates the address calculation performed for each addressing mode. (b) Direct Memory Instruction A Operand (a) Immediate Instruction Operand Registers (d) Register Instruction R (c) Indirect Memory Instruction A Registers (f) Displacement Memory Instruction AR Registers (e) Register indirect Memory Instruction R Top of stack register (g) Stack Implicit Instruction Operand Operand Operand � Figure 13.1 Addressing Modes 454 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS Before beginning this discussion, two comments need to be made. First, virtu- ally all computer architectures provide more than one of these addressing modes. The question arises as to how the processor can determine which address mode is being used in a particular instruction. Several approaches are taken. Often, dif- ferent opcodes will use different addressing modes. Also, one or more bits in the instruction format can be used as a mode field. The value of the mode field deter- mines which addressing mode is to be used. The second comment concerns the interpretation of the effective address (EA). In a system without virtual memory, the effective address will be either a main memory address or a register. In a virtual memory system, the effective address is a virtual address or a register. The actual mapping to a physical address is a function of the memory management unit (MMU) and is invisible to the programmer. Immediate Addressing The simplest form of addressing is immediate addressing, in which the operand value is present in the instruction Operand = A This mode can be used to define and use constants or set initial values of variables. Typically, the number will be stored in twos complement form; the leftmost bit of the operand field is used as a sign bit. When the operand is loaded into a data reg- ister, the sign bit is extended to the left to the full data word size. In some cases, the immediate binary value is interpreted as an unsigned nonnegative integer. The advantage of immediate addressing is that no memory reference other than the instruction fetch is required to obtain the operand, thus saving one mem- ory or cache cycle in the instruction cycle. The disadvantage is that the size of the number is restricted to the size of the address field, which, in most instruction sets, is small compared with the word length. Direct Addressing A very simple form of addressing is direct addressing, in which the address field contains the effective address of the operand: EA = A Table 13.1 Basic Addressing Modes Mode Algorithm Principal Advantage Principal Disadvantage Immediate Operand = A No memory reference Limited operand magnitude Direct EA = A Simple Limited address space Indirect EA = (A) Large address space Multiple memory references Register EA = R No memory reference Limited address space Register indirect EA = (R) Large address space Extra memory reference Displacement EA = A + (R) Flexibility Complexity Stack EA = top of stack No memory reference Limited applicability 13.1 / ADDRESSING MODES 455 The technique was common in earlier generations of computers but is not com- mon on contemporary architectures. It requires only one memory reference and no special calculation. The obvious limitation is that it provides only a limited address space. Indirect Addressing With direct addressing, the length of the address field is usually less than the word length, thus limiting the address range. One solution is to have the address field refer to the address of a word in memory, which in turn contains a full-length address of the operand. This is known as indirect addressing: EA = (A) As defined earlier, the parentheses are to be interpreted as meaning contents of. The obvious advantage of this approach is that for a word length of N, an address space of 2N is now available. The disadvantage is that instruction execution requires two mem- ory references to fetch the operand: one to get its address and a second to get its value. Although the number of words that can be addressed is now equal to 2N, the number of different effective addresses that may be referenced at any one time is limited to 2K, where K is the length of the address field. Typically, this is not a bur- densome restriction, and it can be an asset. In a virtual memory environment, all the effective address locations can be confined to page 0 of any process. Because the address field of an instruction is small, it will naturally produce low-numbered direct addresses, which would appear in page 0. (The only restriction is that the page size must be greater than or equal to 2K.) When a process is active, there will be repeated references to page 0, causing it to remain in real memory. Thus, an indi- rect memory reference will involve, at most, one page fault rather than two. A rarely used variant of indirect addressing is multilevel or cascaded indirect addressing: EA = (c(A)c) In this case, one bit of a full-word address is an indirect flag (I). If the I bit is 0, then the word contains the EA. If the I bit is 1, then another level of indirection is invoked. There does not appear to be any particular advantage to this approach, and its disadvantage is that three or more memory references could be required to fetch an operand. Register Addressing Register addressing is similar to direct addressing. The only difference is that the address field refers to a register rather than a main memory address: EA = R To clarify, if the contents of a register address field in an instruction is 5, then register R5 is the intended address, and the operand value is contained in R5. Typically, an address field that references registers will have from 3 to 5 bits, so that a total of from 8 to 32 general-purpose registers can be referenced. 456 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS The advantages of register addressing are that (1) only a small address field is needed in the instruction, and (2) no time-consuming memory references are required. As was discussed in Chapter 4, the memory access time for a register internal to the processor is much less than that for a main memory address. The disadvantage of register addressing is that the address space is very limited. If register addressing is heavily used in an instruction set, this implies that the processor registers will be heavily used. Because of the severely limited number of registers (compared with main memory locations), their use in this fashion makes sense only if they are employed efficiently. If every operand is brought into a regis- ter from main memory, operated on once, and then returned to main memory, then a wasteful intermediate step has been added. If, instead, the operand in a register remains in use for multiple operations, then a real savings is achieved. An example is the intermediate result in a calculation. In particular, suppose that the algorithm for twos complement multiplication were to be implemented in software. The loca- tion labeled A in the flowchart (Figure 10.12) is referenced many times and should be implemented in a register rather than a main memory location. It is up to the programmer or compiler to decide which values should remain in registers and which should be stored in main memory. Most modern processors employ multiple general-purpose registers, placing a burden for efficient execution on the assembly-language programmer (e.g., compiler writer). Register Indirect Addressing Just as register addressing is analogous to direct addressing, register indirect addressing is analogous to indirect addressing. In both cases, the only difference is whether the address field refers to a memory location or a register. Thus, for regis- ter indirect address, EA = (R) The advantages and limitations of register indirect addressing are basically the same as for indirect addressing. In both cases, the address space limitation (limited range of addresses) of the address field is overcome by having that field refer to a word- length location containing an address. In addition, register indirect addressing uses one less memory reference than indirect addressing. Displacement Addressing A very powerful mode of addressing combines the capabilities of direct addressing and register indirect addressing. It is known by a variety of names depending on the context of its use, but the basic mechanism is the same. We will refer to this as displacement addressing: EA = A + (R) Displacement addressing requires that the instruction have two address fields, at least one of which is explicit. The value contained in one address field (value = A) is used directly. The other address field, or an implicit reference based on opcode, refers to a register whose contents are added to A to produce the effective address. 13.1 / ADDRESSING MODES 457 We will describe three of the most common uses of displacement addressing: • Relative addressing • Base-register addressing • Indexing RELATIVE ADDRESSING For relative addressing, also called PC-relative addressing, the implicitly referenced register is the program counter (PC). That is, the next instruction address is added to the address field to produce the EA. Typically, the address field is treated as a twos complement number for this operation. Thus, the effective address is a displacement relative to the address of the instruction. Relative addressing exploits the concept of locality that was discussed in Chapters 4 and 8. If most memory references are relatively near to the instruction being exe- cuted, then the use of relative addressing saves address bits in the instruction. BASE-REGISTER ADDRESSING For base-register addressing, the interpretation is the following: The referenced register contains a main memory address, and the address field contains a displacement (usually an unsigned integer representation) from that address. The register reference may be explicit or implicit. Base-register addressing also exploits the locality of memory references. It is a convenient means of implementing segmentation, which was discussed in Chapter 8. In some implementations, a single segment-base register is employed and is used implicitly. In others, the programmer may choose a register to hold the base address of a segment, and the instruction must reference it explicitly. In this latter case, if the length of the address field is K and the number of possible registers is N, then one instruction can reference any one of N areas of 2K words. INDEXING For indexing, the interpretation is typically the following: The address field references a main memory address, and the referenced register contains a positive displacement from that address. Note that this usage is just the opposite of the interpretation for base-register addressing. Of course, it is more than just a matter of user interpretation. Because the address field is considered to be a memory address in indexing, it generally contains more bits than an address field in a comparable base-register instruction. Also, we shall see that there are some refinements to indexing that would not be as useful in the base-register context. Nevertheless, the method of calculating the EA is the same for both base-register addressing and indexing, and in both cases the register reference is sometimes explicit and sometimes implicit (for different processor types). An important use of indexing is to provide an efficient mechanism for per- forming iterative operations. Consider, for example, a list of numbers stored start- ing at location A. Suppose that we would like to add 1 to each element on the list. We need to fetch each value, add 1 to it, and store it back. The sequence of effective addresses that we need is A, A + 1, A + 2, . . . , up to the last location on the list. With indexing, this is easily done. The value A is stored in the instruction’s address field, and the chosen register, called an index register, is initialized to 0. After each operation, the index register is incremented by 1. Because index registers are commonly used for such iterative tasks, it is typical that there is a need to increment or decrement the index register after 458 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS each reference to it. Because this is such a common operation, some systems will automatically do this as part of the same instruction cycle. This is known as autoindexing. If certain registers are devoted exclusively to indexing, then autoin- dexing can be invoked implicitly and automatically. If general-purpose registers are used, the autoindex operation may need to be signaled by a bit in the instruc- tion. Autoindexing using increment can be depicted as follows. EA = A + (R) (R) d (R) + 1 In some machines, both indirect addressing and indexing are provided, and it is possible to employ both in the same instruction. There are two possibilities: the indexing is performed either before or after the indirection. If indexing is performed after the indirection, it is termed postindexing: EA = (A) + (R) First, the contents of the address field are used to access a memory location contain- ing a direct address. This address is then indexed by the register value. This tech- nique is useful for accessing one of a number of blocks of data of a fixed format. For example, it was described in Chapter 8 that the operating system needs to employ a process control block for each process. The operations performed are the same regardless of which block is being manipulated. Thus, the addresses in the instruc- tions that reference the block could point to a location (value = A) containing a variable pointer to the start of a process control block. The index register contains the displacement within the block. With preindexing, the indexing is performed before the indirection: EA = (A + (R)) An address is calculated as with simple indexing. In this case, however, the calcu- lated address contains not the operand, but the address of the operand. An example of the use of this technique is to construct a multiway branch table. At a particular point in a program, there may be a branch to one of a number of locations depend- ing on conditions. A table of addresses can be set up starting at location A. By indexing into this table, the required location can be found. Typically, an instruction set will not include both preindexing and postindexing. Stack Addressing The final addressing mode that we consider is stack addressing. As defined in Appendix O, a stack is a linear array of locations. It is sometimes referred to as a pushdown list or last-in-first-out queue. The stack is a reserved block of locations. Items are appended to the top of the stack so that, at any given time, the block is partially filled. Associated with the stack is a pointer whose value is the address of the top of the stack. Alternatively, the top two elements of the stack may be in pro- cessor registers, in which case the stack pointer references the third element of the stack. The stack pointer is maintained in a register. Thus, references to stack loca- tions in memory are in fact register indirect addresses. 13.2 / x86 AND ARM ADDRESSING MODES 459 The stack mode of addressing is a form of implied addressing. The machine instructions need not include a memory reference but implicitly operate on the top of the stack. 13.2 x86 AND ARM ADDRESSING MODES x86 Addressing Modes Recall from Figure 8.21 that the x86 address translation mechanism produces an address, called a virtual or effective address, that is an offset into a segment. The sum of the starting address of the segment and the effective address produces a linear address. If paging is being used, this linear address must pass through a page- translation mechanism to produce a physical address. In what follows, we ignore this last step because it is transparent to the instruction set and to the programmer. The x86 is equipped with a variety of addressing modes intended to allow the efficient execution of high-level languages. Figure 13.2 indicates the logic involved. The segment register determines the segment that is the subject of the reference. There are six segment registers; the one being used for a particular reference depends on the context of execution and the instruction. Each segment register Access rights Limit Base Address SS Access rights Limit Base Address GS Access rights Limit Base Address FS Access rights Limit Base Address ES Access rights Limit Base Address DS Access rights Limit Base Address CS Selector Selector Selector Selector Selector Selector SS GS FS ES DS CS Segment registers Descriptor registers Base register Index register Scale 1, 2, 4, or 8 Displacement (in instruction; 0, 8, or 32 bits) L im it � � � Effective address Linear address Segment base address Figure 13.2 x86 Addressing Mode Calculation 460 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS holds an index into the segment descriptor table (Figure 8.20), which holds the starting address of the corresponding segments. Associated with each user-visible segment register is a segment descriptor register (not programmer visible), which records the access rights for the segment as well as the starting address and limit (length) of the segment. In addition, there are two registers that may be used in constructing an address: the base register and the index register. Table 13.2 lists the x86 addressing modes. Let us consider each of these in turn. For the immediate mode, the operand is included in the instruction. The operand can be a byte, word, or doubleword of data. For register operand mode, the operand is located in a register. For general instructions, such as data transfer, arithmetic, and logical instructions, the operand can be one of the 32-bit general registers (EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP), one of the 16-bit general registers (AX, BX, CX, DX, SI, DI, SP, BP), or one of the 8-bit general registers (AH, BH, CH, DH, AL, BL, CL, DL). There are also some instructions that reference the segment selector registers (CS, DS, ES, SS, FS, GS). The remaining addressing modes reference locations in memory. The memory location must be specified in terms of the segment containing the location and the off- set from the beginning of the segment. In some cases, a segment is specified explicitly; in others, the segment is specified by simple rules that assign a segment by default. In the displacement mode, the operand’s offset (the effective address of Figure13.2) is contained as part of the instruction as an 8-, 16-, or 32-bit dis- placement. With segmentation, all addresses in instructions refer merely to an offset in a segment. The displacement addressing mode is found on few machines because, as mentioned earlier, it leads to long instructions. In the case of the x86, Table 13.2 x86 Addressing Modes Mode Algorithm Immediate Operand = A Register Operand LA = R Displacement LA = (SR) + A Base LA = (SR) + (B) Base with Displacement LA = (SR) + (B) + A Scaled Index with Displacement LA = (SR) + (I) * S + A Base with Index and Displacement LA = (SR) + (B) + (I) + A Base with Scaled Index and Displacement LA = (SR) + (I) * S + (B) + A Relative LA = (PC) + A LA = linear address (X) = contents of X SR = segment register PC = program counter A = contents of an address field in the instruction R = register B = base register I = index register S = scaling factor 13.2 / x86 AND ARM ADDRESSING MODES 461 the displacement value can be as long as 32 bits, making for a 6-byte instruction. Displacement addressing can be useful for referencing global variables. The remaining addressing modes are indirect, in the sense that the address portion of the instruction tells the processor where to look to find the address. The base mode specifies that one of the 8-, 16-, or 32-bit registers contains the effective address. This is equivalent to what we have referred to as register indirect addressing. In the base with displacement mode, the instruction includes a displacement to be added to a base register, which may be any of the general-purpose registers. Examples of uses of this mode are as follows: • Used by a compiler to point to the start of a local variable area. For example, the base register could point to the beginning of a stack frame, which contains the local variables for the corresponding procedure. • Used to index into an array when the element size is not 1, 2, 4, or 8 bytes and which therefore cannot be indexed using an index register. In this case, the displacement points to the beginning of the array, and the base register holds the results of a calculation to determine the offset to a specific element within the array. • Used to access a field of a record. The base register points to the beginning of the record, while the displacement is an offset to the field. In the scaled index with displacement mode, the instruction includes a dis- placement to be added to a register, in this case called an index register. The index register may be any of the general-purpose registers except the one called ESP, which is generally used for stack processing. In calculating the effective address, the contents of the index register are multiplied by a scaling factor of 1, 2, 4, or 8, and then added to a displacement. This mode is very convenient for indexing arrays. A scaling factor of 2 can be used for an array of 16-bit integers. A scaling factor of 4 can be used for 32-bit integers or floating-point numbers. Finally, a scaling factor of 8 can be used for an array of double-precision floating-point numbers. The base with index and displacement mode sums the contents of the base register, the index register, and a displacement to form the effective address. Again, the base register can be any general-purpose register and the index register can be any general-purpose register except ESP. As an example, this addressing mode could be used for accessing a local array on a stack frame. This mode can also be used to support a two-dimensional array; in this case, the displacement points to the beginning of the array, and each register handles one dimension of the array. The based scaled index with displacement mode sums the contents of the index register multiplied by a scaling factor, the contents of the base register, and the displace- ment. This is useful if an array is stored in a stack frame; in this case, the array elements would be 2, 4, or 8 bytes each in length. This mode also provides efficient indexing of a two-dimensional array when the array elements are 2, 4, or 8 bytes in length. Finally, relative addressing can be used in transfer-of-control instructions. A dis- placement is added to the value of the program counter, which points to the next instruc- tion. In this case, the displacement is treated as a signed byte, word, or doubleword value, and that value either increases or decreases the address in the program counter. 462 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS ARM Addressing Modes Typically, a RISC machine, unlike a CISC machine, uses a simple and relatively straightforward set of addressing modes. The ARM architecture departs somewhat from this tradition by providing a relatively rich set of addressing modes. These modes are most conveniently classified with respect to the type of instruction.1 LOAD/STORE ADDRESSING Load and store instructions are the only instructions that reference memory. This is always done indirectly through a base register plus offset. There are three alternatives with respect to indexing (Figure 13.3): • Offset: For this addressing method, indexing is not used. An offset value is added to or subtracted from the value in the base register to form the memory address. As an example Figure 13.3a illustrates this method with the assembly language instruction STRB r0, [r1, #12]. This is the store byte instruc- tion. In this case the base address is in register r1 and the displacement is an immediate value of decimal 12. The resulting address (base plus offset) is the location where the least significant byte from r0 is to be stored. • Preindex: The memory address is formed in the same way as for offset address- ing. The memory address is also written back to the base register. In other words, the base register value is incremented or decremented by the offset value. Figure 13.3b illustrates this method with the assembly language instruc- tion STRB r0, [r1, #12]!. The exclamation point signifies preindexing. • Postindex: The memory address is the base register value. An offset is added to or subtracted from the base register value and the result is written back to the base register. Figure 13.3c illustrates this method with the assembly lan- guage instruction STRB r0, [r1], #12. Note that what ARM refers to as a base register acts as an index register for preindex and postindex addressing. The offset value can either be an immediate value stored in the instruction or it can be in another register. If the offset value is in a register, another useful feature is available: scaled register addressing. The value in the offset register is scaled by one of the shift operators: Logical Shift Left, Logical Shift Right, Arithmetic Shift Right, Rotate Right, or Rotate Right Extended (which includes the carry bit in the rotation). The amount of the shift is specified as an immediate value in the instruction. DATA PROCESSING INSTRUCTION ADDRESSING Data processing instructions use either register addressing or a mixture of register and immediate addressing. For register addressing, the value in one of the register operands may be scaled using one of the five shift operators defined in the preceding paragraph. BRANCH INSTRUCTIONS The only form of addressing for branch instructions is immediate addressing. The branch instruction contains a 24-bit value. For address calculation, this value is shifted left 2 bits, so that the address is on a word boundary. Thus the effective address range is {32 MB from the program counter. 1As with our discussion of x86 addressing, we ignore the translation from virtual to physical address in the following discussion. 13.2 / x86 AND ARM ADDRESSING MODES 463 LOAD/STORE MULTIPLE ADDRESSING Load Multiple instructions load a subset (possibly all) of the general-purpose registers from memory. Store Multiple instructions store a subset (possibly all) of the general-purpose registers to memory. The list of registers for the load or store is specified in a 16-bit field in the instruction with each bit corresponding to one of the 16 registers. Load and Store Multiple addressing modes produce a sequential range of memory addresses. The lowest-numbered register is stored at the lowest memory address and the highest- numbered register at the highest memory address. Four addressing modes are used 0x200 0x200 0x20C0x20C 0xC r1 r1 Original base register (b) Preindex (c) Postindex Destination register for STR Updated base register 0x5 0x5 r0 Offset STRB r0, [r1, #12]! 0x200 0x200 0x20C0x20C 0xC r1 r1 Original base register Destination register for STR Updated base register 0x5 0x5 r0 Offset STRB r0, [r1], #12 0x200 0x200 0x20C0xC r1 Original base register (a) Offset Destination register for STR 0x5 0x5 r0 Offset STRB r0, [r1, #12] Figure 13.3 ARM Indexing Methods 464 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS (Figure 13.4): increment after, increment before, decrement after, and decrement before. A base register specifies a main memory address where register values are stored in or loaded from in ascending (increment) or descending (decrement) word locations. Incrementing or decrementing starts either before or after the first memory access. These instructions are useful for block loads or stores, stack operations, and procedure exit sequences. 13.3 INSTRUCTION FORMATS An instruction format defines the layout of the bits of an instruction, in terms of its constituent fields. An instruction format must include an opcode and, implicitly or explicitly, zero or more operands. Each explicit operand is referenced using one of the addressing modes described in Section 13.1. The format must, implicitly or explicitly, indicate the addressing mode for each operand. For most instruction sets, more than one instruction format is used. The design of an instruction format is a complex art, and an amazing variety of designs have been implemented. We examine the key design issues, looking briefly at some designs to illustrate points, and then we examine the x86 and ARM solu- tions in detail. Instruction Length The most basic design issue to be faced is the instruction format length. This deci- sion affects, and is affected by, memory size, memory organization, bus structure, processor complexity, and processor speed. This decision determines the richness and flexibility of the machine as seen by the assembly-language programmer. The most obvious trade-off here is between the desire for a powerful instruc- tion repertoire and a need to save space. Programmers want more opcodes, more operands, more addressing modes, and greater address range. More opcodes and more operands make life easier for the programmer, because shorter programs can 0x20C 0x210 0x214 0x20C(r0) (r1) (r4) (r0) (r1) (r4) (r0) (r1) (r4) (r0) (r1) (r4) 0x208 0x204 0x200 0x218 r10 Base register Increment after (IA) Increment before (IB) Decrement after (DA) Decrement before (DB) LDMxx r10, {r0, r1, r4} STMxx r10, {r0, r1, r4} Figure 13.4 ARM Load/Store Multiple Addressing 13.3 / INSTRUCTION FORMATS 465 be written to accomplish given tasks. Similarly, more addressing modes give the pro- grammer greater flexibility in implementing certain functions, such as table manipu- lations and multiple-way branching. And, of course, with the increase in main mem- ory size and the increasing use of virtual memory, programmers want to be able to address larger memory ranges. All of these things (opcodes, operands, addressing modes, address range) require bits and push in the direction of longer instruction lengths. But longer instruction length may be wasteful. A 64-bit instruction occupies twice the space of a 32-bit instruction but is probably less than twice as useful. Beyond this basic trade-off, there are other considerations. Either the instruc- tion length should be equal to the memory-transfer length (in a bus system, data- bus length) or one should be a multiple of the other. Otherwise, we will not get an integral number of instructions during a fetch cycle. A related consideration is the memory transfer rate. This rate has not kept up with increases in processor speed. Accordingly, memory can become a bottleneck if the processor can execute instructions faster than it can fetch them. One solution to this problem is to use cache memory (see Section 4.3); another is to use shorter instructions. Thus, 16-bit instructions can be fetched at twice the rate of 32-bit instructions but probably can be executed less than twice as rapidly. A seemingly mundane but nevertheless important feature is that the instruc- tion length should be a multiple of the character length, which is usually 8 bits, and of the length of fixed-point numbers. To see this, we need to make use of that unfor- tunately ill-defined word, word [FRAI83]. The word length of memory is, in some sense, the “natural” unit of organization. The size of a word usually determines the size of fixed-point numbers (usually the two are equal). Word size is also typically equal to, or at least integrally related to, the memory transfer size. Because a com- mon form of data is character data, we would like a word to store an integral number of characters. Otherwise, there are wasted bits in each word when storing multiple characters, or a character will have to straddle a word boundary. The importance of this point is such that IBM, when it introduced the System/360 and wanted to employ 8-bit characters, made the wrenching decision to move from the 36-bit archi- tecture of the scientific members of the 700/7000 series to a 32-bit architecture. Allocation of Bits We’ve looked at some of the factors that go into deciding the length of the instruc- tion format. An equally difficult issue is how to allocate the bits in that format. The trade-offs here are complex. For a given instruction length, there is clearly a trade-off between the number of opcodes and the power of the addressing capability. More opcodes obviously mean more bits in the opcode field. For an instruction format of a given length, this reduces the number of bits available for addressing. There is one interesting refinement to this trade-off, and that is the use of variable-length opcodes. In this approach, there is a minimum opcode length but, for some opcodes, additional operations may be specified by using additional bits in the instruction. For a fixed- length instruction, this leaves fewer bits for addressing. Thus, this feature is used for those instructions that require fewer operands and/or less powerful addressing. 466 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS The following interrelated factors go into determining the use of the address- ing bits. • Number of addressing modes: Sometimes an addressing mode can be indi- cated implicitly. For example, certain opcodes might always call for indexing. In other cases, the addressing modes must be explicit, and one or more mode bits will be needed. • Number of operands: We have seen that fewer addresses can make for longer, more awkward programs (e.g., Figure 10.3). Typical instruction formats on today’s machines include two operands. Each operand address in the instruc- tion might require its own mode indicator, or the use of a mode indicator could be limited to just one of the address fields. • Register versus memory: A machine must have registers so that data can be brought into the processor for processing. With a single user-visible register (usually called the accumulator), one operand address is implicit and con- sumes no instruction bits. However, single-register programming is awkward and requires many instructions. Even with multiple registers, only a few bits are needed to specify the register. The more that registers can be used for operand references, the fewer bits are needed. A number of studies indicate that a total of 8 to 32 user-visible registers is desirable [LUND77, HUCK83]. Most contemporary architectures have at least 32 registers. • Number of register sets: Most contemporary machines have one set of general- purpose registers, with typically 32 or more registers in the set. These registers can be used to store data and can be used to store addresses for displacement addressing. Some architectures, including that of the x86, have a collection of two or more specialized sets (such as data and displacement). One advantage of this latter approach is that, for a fixed number of registers, a functional split requires fewer bits to be used in the instruction. For example, with two sets of eight registers, only 3 bits are required to identify a register; the opcode or mode register will determine which set of registers is being referenced. • Address range: For addresses that reference memory, the range of addresses that can be referenced is related to the number of address bits. Because this imposes a severe limitation, direct addressing is rarely used. With displace- ment addressing, the range is opened up to the length of the address register. Even so, it is still convenient to allow rather large displacements from the reg- ister address, which requires a relatively large number of address bits in the instruction. • Address granularity: For addresses that reference memory rather than reg- isters, another factor is the granularity of addressing. In a system with 16- or 32-bit words, an address can reference a word or a byte at the designer’s choice. Byte addressing is convenient for character manipulation but requires, for a fixed-size memory, more address bits. Thus, the designer is faced with a host of factors to consider and balance. How critical the various choices are is not clear. As an example, we cite one study [CRAG79] that compared various instruction format approaches, including the use 13.3 / INSTRUCTION FORMATS 467 of a stack, general-purpose registers, an accumulator, and only memory-to-register approaches. Using a consistent set of assumptions, no significant difference in code space or execution time was observed. Let us briefly look at how two historical machine designs balance these vari- ous factors. PDP-8 One of the simplest instruction designs for a general-purpose computer was for the PDP-8 [BELL78b]. The PDP-8 uses 12-bit instructions and operates on 12-bit words. There is a single general-purpose register, the accumulator. Despite the limitations of this design, the addressing is quite flexible. Each memory reference consists of 7 bits plus two 1-bit modifiers. The memory is divided into fixed-length pages of 27 = 128 words each. Address calculation is based on references to page 0 or the current page (page containing this instruction) as deter- mined by the page bit. The second modifier bit indicates whether direct or indirect addressing is to be used. These two modes can be used in combination, so that an indirect address is a 12-bit address contained in a word of page 0 or the current page. In addition, 8 dedicated words on page 0 are autoindex “registers.” When an indirect reference is made to one of these locations, preindexing occurs. Figure 13.5 shows the PDP-8 instruction format. There are a 3-bit opcode and three types of instructions. For opcodes 0 through 5, the format is a single-address memory reference instruction including a page bit and an indirect bit. Thus, there are only six basic operations. To enlarge the group of operations, opcode 7 defines Memory reference instructions Opcode D/I Z/C Displacement 0 2 3 4 5 11 Input/output instructions 1 1 0 Device Opcode 0 2 3 8 9 11 Register reference instructions Group 1 microinstructions 1 1 1 0 CLA CLL CMA CML RAR RAL BSW IAC 0 1 2 3 Group 2 microinstructions 1 1 1 0 0 1 2 3 Group 3 microinstructions 1 1 1 0 0 1 2 3 4 5 6 7 8 9 10 11 CLA SMA SZA SNL RSS OSR HLT 0 4 5 6 7 8 9 10 11 CLA MQA 0 MQL 0 0 0 1 4 5 6 7 8 9 10 11 D/I � Direct/Indirect address Z/C � Page 0 or Current page CLA � Clear Accumulator CLL � Clear Link CMA � CoMplement Accumulator CML � CoMplement Link RAR � Rotate Accumulator Right RAL � Rotate Accumulator Left BSW � Byte SWap IAC � Increment ACcumulator SMA � Skip on Minus Accumulator SZA � Skip on Zero Accumulator SNL � Skip on Nonzero Link RSS � Reverse Skip Sense OSR � Or with Switch Register HLT � HaLT MQA� Multiplier Quotient into Accumulator MQL � Multiplier Quotient Load Figure 13.5 PDP-8 Instruction Formats 468 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS a register reference or microinstruction. In this format, the remaining bits are used to encode additional operations. In general, each bit defines a specific operation (e.g., clear accumulator), and these bits can be combined in a single instruction. The microinstruction strategy was used as far back as the PDP-1 by DEC and is, in a sense, a forerunner of today’s microprogrammed machines, to be discussed in Part Four. Opcode 6 is the I/O operation; 6 bits are used to select one of 64 devices, and 3 bits specify a particular I/O command. The PDP-8 instruction format is remarkably efficient. It supports indirect addressing, displacement addressing, and indexing. With the use of the opcode extension, it supports a total of approximately 35 instructions. Given the constraints of a 12-bit instruction length, the designers could hardly have done better. PDP-10 A sharp contrast to the instruction set of the PDP-8 is that of the PDP-10. The PDP-10 was designed to be a large-scale time-shared system, with an emphasis on making the system easy to program, even if additional hardware expense was involved. Among the design principles employed in designing the instruction set were the following [BELL78c]: • Orthogonality: Orthogonality is a principle by which two variables are inde- pendent of each other. In the context of an instruction set, the term indicates that other elements of an instruction are independent of (not determined by) the opcode. The PDP-10 designers use the term to describe the fact that an address is always computed in the same way, independent of the opcode. This is in contrast to many machines, where the address mode sometimes depends implicitly on the operator being used. • Completeness: Each arithmetic data type (integer, fixed-point, floating-point) should have a complete and identical set of operations. • Direct addressing: Base plus displacement addressing, which places a mem- ory organization burden on the programmer, was avoided in favor of direct addressing. Each of these principles advances the main goal of ease of programming. The PDP-10 has a 36-bit word length and a 36-bit instruction length. The fixed instruction format is shown in Figure 13.6. The opcode occupies 9 bits, allowing up to 512 operations. In fact, a total of 365 different instructions are defined. Most instructions have two addresses, one of which is one of 16 general-purpose registers. Thus, this operand reference occupies 4 bits. The other operand reference starts with an 18-bit memory address field. This can be used as an immediate operand or a memory address. In the latter usage, both indexing and indirect addressing are allowed. The same general-purpose registers are also used as index registers. Index register Memory address 0 8 9 12 14 17 18 35 I � indirect bit Opcode Register I Figure 13.6 PDP-10 Instruction Format 13.3 / INSTRUCTION FORMATS 469 A 36-bit instruction length is true luxury. There is no need to do clever things to get more opcodes; a 9-bit opcode field is more than adequate. Addressing is also straightforward. An 18-bit address field makes direct addressing desirable. For memory sizes greater than 218, indirection is provided. For the ease of the program- mer, indexing is provided for table manipulation and iterative programs. Also, with an 18-bit operand field, immediate addressing becomes attractive. The PDP-10 instruction set design does accomplish the objectives listed ear- lier [LUND77]. It eases the task of the programmer or compiler at the expense of an inefficient utilization of space. This was a conscious choice made by the designers and therefore cannot be faulted as poor design. Variable-Length Instructions The examples we have looked at so far have used a single fixed instruction length, and we have implicitly discussed trade-offs in that context. But the designer may choose instead to provide a variety of instruction formats of different lengths. This tactic makes it easy to provide a large repertoire of opcodes, with different opcode lengths. Addressing can be more flexible, with various combinations of register and memory references plus addressing modes. With variable-length instructions, these many variations can be provided efficiently and compactly. The principal price to pay for variable-length instructions is an increase in the complexity of the processor. Falling hardware prices, the use of microprogramming (discussed in Part Four), and a general increase in understanding the principles of processor design have all contributed to making this a small price to pay. However, we will see that RISC and superscalar machines can exploit the use of fixed-length instructions to provide improved performance. The use of variable-length instructions does not remove the desirability of making all of the instruction lengths integrally related to the word length. Because the processor does not know the length of the next instruction to be fetched, a typical strategy is to fetch a number of bytes or words equal to at least the longest possible instruction. This means that sometimes multiple instructions are fetched. However, as we shall see in Chapter 14, this is a good strategy to follow in any case. PDP-11 The PDP-11 was designed to provide a powerful and flexible instruction set within the constraints of a 16-bit minicomputer [BELL70]. The PDP-11 employs a set of eight 16-bit general-purpose registers. Two of these registers have additional significance: one is used as a stack pointer for spe- cial-purpose stack operations, and one is used as the program counter, which con- tains the address of the next instruction. Figure 13.7 shows the PDP-11 instruction formats. Thirteen different formats are used, encompassing zero-, one-, and two-address instruction types. The opcode can vary from 4 to 16 bits in length. Register references are 6 bits in length. Three bits identify the register, and the remaining 3 bits identify the addressing mode. The PDP-11 is endowed with a rich set of addressing modes. One advantage of linking the addressing mode to the operand rather than the opcode, as is sometimes done, is that any addressing mode can be used with any opcode. As was mentioned, this independence is referred to as orthogonality. 4 7 0 Opcode Opcode Offset1 2 3 4 5 6 7 10 11 12 13 Numbers below fields indicate bit length Source and destination each contain a 3-bit addressing mode field and a 3-bit register number FP indicates one of four floating-point registers R indicates one of the general-purpose registers CC is the condition code field 8 9 RSource SourceDestinationOpcode 4 Opcode 8 Opcode 10 Opcode 12 CC 4 FP 2 Destination 6 Destination 6 Opcode 13 Opcode 16 Opcode 4 Source 6 Destination 6 Memory address 16 R 3 Opcode 7 Source 6 Source 6 Destination 6 Destination 6 Memory address 16 Memory address 16 Memory address 16 Memory address 1 16 Memory address 2 16 R 3 Opcode 8 FP 2 Opcode 10 Opcode 4 Source 6 7 8 836 66 Figure 13.7 Instruction Formats for the PDP-11 13.3 / INSTRUCTION FORMATS 471 PDP-11 instructions are usually one word (16 bits) long. For some instructions, one or two memory addresses are appended, so that 32-bit and 48-bit instructions are part of the repertoire. This provides for further flexibility in addressing. The PDP-11 instruction set and addressing capability are complex. This increases both hardware cost and programming complexity. The advantage is that more efficient or compact programs can be developed. VAX Most architectures provide a relatively small number of fixed instruction formats. This can cause two problems for the programmer. First, addressing mode and opcode are not orthogonal. For example, for a given operation, one operand must come from a register and another from memory, or both from registers, and so on. Second, only a limited number of operands can be accommodated: typically up to two or three. Because some operations inherently require more operands, various strategies must be used to achieve the desired result using two or more instructions. To avoid these problems, two criteria were used in designing the VAX instruc- tion format [STRE78]: 1. All instructions should have the “natural” number of operands. 2. All operands should have the same generality in specification. The result is a highly variable instruction format. An instruction consists of a 1- or 2-byte opcode followed by from zero to six operand specifiers, depending on the opcode. The minimal instruction length is 1 byte, and instructions up to 37 bytes can be constructed. Figure 13.8 gives a few examples. The VAX instruction begins with a 1-byte opcode. This suffices to handle most VAX instructions. However, as there are over 300 different instructions, 8 bits are not enough. The hexadecimal codes FD and FF indicate an extended opcode, with the actual opcode being specified in the second byte. The remainder of the instruction consists of up to six operand specifiers. An operand specifier is, at minimum, a 1-byte format in which the leftmost 4 bits are the address mode specifier. The only exception to this rule is the literal mode, which is signaled by the pattern 00 in the leftmost 2 bits, leaving space for a 6-bit literal. Because of this exception, a total of 12 different addressing modes can be specified. An operand specifier often consists of just one byte, with the rightmost 4 bits specifying one of 16 general-purpose registers. The length of the operand specifier can be extended in one of two ways. First, a constant value of one or more bytes may immediately follow the first byte of the operand specifier. An example of this is the displacement mode, in which an 8-, 16-, or 32-bit displace- ment is used. Second, an index mode of addressing may be used. In this case, the first byte of the operand specifier consists of the 4-bit addressing mode code of 0100 and a 4-bit index register identifier. The remainder of the operand specifier consists of the base address specifier, which may itself be one or more bytes in length. The reader may be wondering, as the author did, what kind of instruction requires six operands. Surprisingly, the VAX has a number of such instructions. Consider ADDP6 OP1, OP2, OP3, OP4, OP5, OP6 472 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS This instruction adds two packed decimal numbers. OP1 and OP2 specify the length and starting address of one decimal string; OP3 and OP4 specify a second string. These two strings are added and the result is stored in the decimal string whose length and starting location are specified by OP5 and OP6. The VAX instruction set provides for a wide variety of operations and address- ing modes. This gives a programmer, such as a compiler writer, a very powerful and flexible tool for developing programs. In theory, this should lead to efficient machine-language compilations of high-level language programs and, in general, to effective and efficient use of processor resources. The penalty to be paid for these benefits is the increased complexity of the processor compared with a processor with a simpler instruction set and format. We return to these matters in Chapter 15, where we examine the case for very simple instruction sets. Opcode for RSB Hexadecimal Format Assembler Notation and Description Explanation 0 8 bits 5 D 4 5 9 B 0 C 4 6 4 0 1 A B 1 9 C 1 0 5 5 0 4 2 D F RSB Return from subroutine Opcode for CLRL Register R9 CLRL R9 Clear register R9 Opcode for MOVW Word displacement mode, Register R4 Byte displacement mode, Register R11 25 in hexadecimal 356 in hexadecimal MOVW 356(R4), 25(R11) Move a word from address that is 356 plus contents of R4 to address that is 25 plus contents of R11 Opcode for ADDL3 Short literal 5 Register mode R0 Index prefix R2 Indirect word relative (displacement from PC) ADDL3 #5, R0, @A[R2] Add 5 to a 32-bit integer in R0 and store the result in location whose address is sum of A and 4 times the contents of R2 Amount of displacement from PC relative to location A Figure 13.8 Example of VAX Instructions 13.4 / x86 AND ARM INSTRUCTION FORMATS 473 13.4 x86 AND ARM INSTRUCTION FORMATS x86 Instruction Formats The x86 is equipped with a variety of instruction formats. Of the elements described in this subsection, only the opcode field is always present. Figure 13.9 illustrates the general instruction format. Instructions are made up of from zero to four optional instruction prefixes, a 1- or 2-byte opcode, an optional address specifier (which con- sists of the ModR/M byte and the Scale Index Base byte) an optional displacement, and an optional immediate field. Let us first consider the prefix bytes: • Instruction prefixes: The instruction prefix, if present, consists of the LOCK prefix or one of the repeat prefixes. The LOCK prefix is used to ensure exclusive use of shared memory in multiprocessor environments. The repeat prefixes specify repeated operation of a string, which enables the x86 to pro- cess strings much faster than with a regular software loop. There are five dif- ferent repeat prefixes: REP, REPE, REPZ, REPNE, and REPNZ. When the absolute REP prefix is present, the operation specified in the instruction is executed repeatedly on successive elements of the string; the number of repeti- tions is specified in register CX. The conditional REP prefix causes the instruc- tion to repeat until the count in CX goes to zero or until the condition is met. • Segment override: Explicitly specifies which segment register an instruction should use, overriding the default segment-register selection generated by the x86 for that instruction. Mod bytes0 or 1 0, 1, 2, 3, or 4 bytes 0, 1, 2, or 4 0, 1, 2, or 41, 2, or 3 0 or 1 0 or 1 0 or 1 0 or 1 0 or 1 Instruction prefixes Opcode 01234567 01234567 ModR/M SIB Displacement Immediate Instruction prefix Segment override Operand size override Address size override Reg/Opcode R/M Scale Index Base Figure 13.9 x86 Instruction Format 474 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS • Operand size: An instruction has a default operand size of 16 or 32 bits, and the operand prefix switches between 32-bit and 16-bit operands. • Address size: The processor can address memory using either 16- or 32-bit addresses. The address size determines the displacement size in instructions and the size of address offsets generated during effective address calculation. One of these sizes is designated as default, and the address size prefix switches between 32-bit and 16-bit address generation. The instruction itself includes the following fields: • Opcode: The opcode field is 1, 2, or 3 bytes in length. The opcode may also include bits that specify if data is byte- or full-size (16 or 32 bits depending on context), direction of data operation (to or from memory), and whether an im- mediate data field must be sign extended. • ModR/M: This byte, and the next, provide addressing information. The ModR/M byte specifies whether an operand is in a register or in memory; if it is in memory, then fields within the byte specify the addressing mode to be used. The ModR/M byte consists of three fields: The Mod field (2 bits) com- bines with the R/M field to form 32 possible values: 8 registers and 24 index- ing modes; the Reg/Opcode field (3 bits) specifies either a register number or three more bits of opcode information; the r/m field (3 bits) can specify a reg- ister as the location of an operand, or it can form part of the addressing-mode encoding in combination with the Mod field. • SIB: Certain encoding of the ModR/M byte specifies the inclusion of the SIB byte to specify fully the addressing mode. The SIB byte consists of three fields: The Scale field (2 bits) specifies the scale factor for scaled indexing; the Index field (3 bits) specifies the index register; the Base field (3 bits) specifies the base register. • Displacement: When the addressing-mode specifier indicates that a displace- ment is used, an 8-, 16-, or 32-bit signed integer displacement field is added. • Immediate: Provides the value of an 8-, 16-, or 32-bit operand. Several comparisons may be useful here. In the x86 format, the addressing mode is provided as part of the opcode sequence rather than with each operand. Because only one operand can have address-mode information, only one memory operand can be referenced in an instruction. In contrast, the VAX carries the address-mode information with each operand, allowing memory-to-memory operations. The x86 instructions are therefore more compact. However, if a memory- to-memory opera- tion is required, the VAX can accomplish this in a single instruction. The x86 format allows the use of not only 1-byte, but also 2-byte and 4-byte offsets for indexing. Although the use of the larger index offsets results in longer instructions, this feature provides needed flexibility. For example, it is useful in addressing large arrays or large stack frames. In contrast, the IBM S/370 instruc- tion format allows offsets no greater than 4 Kbytes (12 bits of offset information), and the offset must be positive. When a location is not in reach of this offset, the compiler must generate extra code to generate the needed address. This problem is 13.4 / x86 AND ARM INSTRUCTION FORMATS 475 especially apparent in dealing with stack frames that have local variables occupying in excess of 4 Kbytes. As [DEWA90] puts it, “generating code for the 370 is so painful as a result of that restriction that there have even been compilers for the 370 that simply chose to limit the size of the stack frame to 4 Kbytes.” As can be seen, the encoding of the x86 instruction set is very complex. This has to do partly with the need to be backward compatible with the 8086 machine and partly with a desire on the part of the designers to provide every possible assist- ance to the compiler writer in producing efficient code. It is a matter of some debate whether an instruction set as complex as this is preferable to the opposite extreme of the RISC instruction sets. ARM Instruction Formats All instructions in the ARM architecture are 32 bits long and follow a regular for- mat (Figure 13.10). The first four bits of an instruction are the condition code. As discussed in Chapter 12, virtually all ARM instructions can be conditionally executed. The next three bits specify the general type of instruction. For most instruc- tions other than branch instructions, the next five bits constitute an opcode and/or modifier bits for the operation. The remaining 20 bits are for operand addressing. The regular structure of the instruction formats eases the job of the instruction decode units. 0 0 0S Rn RmRd Shift amount Shift 0Shift amount Shift 0Cond Opcode Data processing immediate shift 0 1 S Rn Rd Rotate Immediate0Cond Opcode Data processing immediate 1 0 LWBUP Rn Rd Immediate0Cond Load/store immediate offset 1 1 LWBUP Rn Rd0Cond Load/store register offset 0 0 10S Rn Rm Rm Register list0 0 LWSUP Rn1Cond Load/store multiple 24-Bit offset0 1 L1Cond Branch/branch with link S = For data processing instructions, signifies that the instruction updates the condition codes S = For load/store multiple instructions, signifies whether instruction execution is restricted to supervisor mode P, U, W = Bits that distinguish among different types of addressing_mode B = Distinguishes between an unsigned byte (B==1) and a word (B==0) access L = For load/store instructions, distinguishes between a Load (L==1) and a Store (L==0) L = For branch instructions, determines whether a return address is stored in the link register Rd Rs Shift0Cond Opcode Data processing register shift 012345678910111214 131517 161820 1922 2124 2326 2528 2730 2931 Figure 13.10 ARM Instruction Formats 476 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS IMMEDIATE CONSTANTS To achieve a greater range of immediate values, the data processing immediate format specifies both an immediate value and a rotate value. The 8-bit immediate value is expanded to 32 bits and then rotated right by a number of bits equal to twice the 4-bit rotate value. Several examples are shown in Figure 13.11. THUMB INSTRUCTION SET The Thumb instruction set is a re-encoded subset of the ARM instruction set. Thumb is designed to increase the performance of ARM implementations that use a 16-bit or narrower memory data bus and to allow better code density than provided by the ARM instruction set. The Thumb instruction set contains a subset of the ARM 32-bit instruction set recoded into 16-bit instructions. The savings is achieved in the following way: 1. Thumb instructions are unconditional, so the condition code field is not used. Also, all Thumb arithmetic and logic instructions update the condition flags, so that the update-flag bit is not needed. Savings: 5 bits. 2. Thumb has only a subset of the operations in the full instruction set and uses only a 2-bit opcode field, plus a 3-bit type field. Savings: 2 bits. 3. The remaining savings of 9 bits comes from reductions in the operand specifi- cations. For example, Thumb instructions reference only registers r0 through r7, so only 3 bits are required for register references, rather than 4 bits. Immediate values do not include a 4-bit rotate field. The ARM processor can execute a program consisting of a mixture of Thumb instructions and 32-bit ARM instructions. A bit in the processor control register determines which type of instruction is currently being executed. Figure 13.12 shows an example. The figure shows both the general format and a specific instance of an instruction in both 16-bit and 32-bit formats. 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 000000 ror #0—range 0 through 0x000000FF—step 0x00000001 012345678910111214 131517 161820 1922 2124 2326 2528 2730 2931 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ror #8—range 0 through 0xFF000000—step 0x01000000 012345678910111214 131517 161820 1922 2124 2326 2528 2730 2931 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 000000 ror #30—range 0 through 0x000003FC—step 0x00000004 012345678910111214 131517 161820 1922 2124 2326 2528 2730 2931 Figure 13.11 Examples of Use of ARM Immediate Constants 13.5 / ASSEMBLY LANGUAGE 477 13.5 ASSEMBLY LANGUAGE A processor can understand and execute machine instructions. Such instructions are simply binary numbers stored in the computer. If a programmer wished to program directly in machine language, then it would be necessary to enter the program as binary data. Consider the simple BASIC statement N = I + J + K Suppose we wished to program this statement in machine language and to initialize I, J, and K to 2, 3, and 4, respectively. This is shown in Figure 13.13a. The program starts in location 101 (hexadecimal). Memory is reserved for the four variables start- ing at location 201. The program consists of four instructions: 1. Load the contents of location 201 into the AC. 2. Add the contents of location 202 to the AC. 3. Add the contents of location 203 to the AC. 4. Store the contents of the AC in location 204. This is clearly a tedious and very error-prone process. A slight improvement is to write the program in hexadecimal rather than binary notation (Figure 10.11b). We could write the program as a series of lines. Each line contains the address of a memory location and the hexadecimal code of the binary value to be stored in that location. Then we need a program that will accept this input, translate each line into a binary number, and store it in the speci- fied location. For more improvement, we can make use of the symbolic name or mnemonic of each instruction. This results in the symbolic program shown in Figure 10.11c. Each line of input still represents one memory location. Each line consists of three 0 1 1 0 00 0 10 00 10 1 10 11 11 0 0 0 0 0 010 0 0 1 1 ADD r3, #19 ADDS r3, r3, #19 Data processing immediate format 012345678910111214 131517 161820 1922 2124 2326 2528 2730 2931 0 1 1 00 1 10 0 0 1 00 1 10 Add/subtract/compare/move immediate format Always condition code Update condition flags Zero rotation 0 1 Rd/RnOpcode Immediate0 012345678910111214 1315 0 1 S Rn Rd Rotate Immediate0Cond Opcode Figure 13.12 Expanding a Thumb ADD Instruction into its ARM Equivalent 478 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS fields, separated by spaces. The first field contains the address of a location. For an instruction, the second field contains the three-letter symbol for the opcode. If it is a memory-referencing instruction, then a third field contains the address. To store arbitrary data in a location, we invent a pseudoinstruction with the symbol DAT. This is merely an indication that the third field on the line contains a hexadecimal number to be stored in the location specified in the first field. For this type of input we need a slightly more complex program. The program accepts each line of input, generates a binary number based on the second and third (if present) fields, and stores it in the location specified by the first field. The use of a symbolic program makes life much easier but is still awkward. In particular, we must give an absolute address for each word. This means that the program and data can be loaded into only one place in memory, and we must know that place ahead of time. Worse, suppose we wish to change the program some day by adding or deleting a line. This will change the addresses of all subsequent words. A much better system, and one commonly used, is to use symbolic addresses. This is illustrated in Figure 10.11d. Each line still consists of three fields. The first field is still for the address, but a symbol is used instead of an absolute numerical address. Some lines have no address, implying that the address of that line is one more than the address of the previous line. For memory-reference instructions, the third field also contains a symbolic address. With this last refinement, we have an assembly language. Programs written in assembly language (assembly programs) are translated into machine language by an assembler. This program must not only do the symbolic translation discussed earlier but also assign some form of memory addresses to symbolic addresses. Address Contents 101 0010 0010 101 2201 101 2201 102 0001 0010 102 1202 102 1202 103 0001 0010 103 1203 103 1203 104 0011 0010 104 3204 104 3204 201 0000 0000 201 0002 201 0002 202 0000 0000 202 0003 202 0003 203 0000 0000 203 0004 203 0004 204 0000 0000 204 0000 204 0000 (a) Binary program (b) Hexadecimal program Address Instruction Label Operation Operand 101 LDA 201 FORMUL LDA I 102 ADD 202 ADD J 103 ADD 203 ADD K 104 STA 204 STA N 201 DAT 2 I DATA 2 202 DAT 3 J DATA 3 203 DAT 4 K DATA 4 204 DAT 0 N DATA 0 (c) Symbolic program (d) Assembly program ContentsAddress Figure 13.13 Computation of the Formula N = I + J + K 13.7 / KEY TERMS, REVIEW QUESTIONS, AND PROBLEMS 479 Review Questions 13.1 Briefly define immediate addressing. 13.2 Briefly define direct addressing. 13.3 Briefly define indirect addressing. 13.4 Briefly define register addressing. 13.5 Briefly define register indirect addressing. 13.6 Briefly define displacement addressing. 13.7 Briefly define relative addressing. 13.8 What is the advantage of autoindexing? 13.9 What is the difference between postindexing and preindexing? 13.10 What facts go into determining the use of the addressing bits of an instruction? 13.11 What are the advantages and disadvantages of using a variable-length instruction format? BLAA97 Blaauw, G., and Brooks, F. Computer Architecture: Concepts and Evolution. Reading, MA: Addison-Wesley, 1997. FLYN85 Flynn, M.; Johnson, J.; and Wakefield, S. “On Instruction Sets and Their Formats.” IEEE Transactions on Computers, March 1985. The development of assembly language was a major milestone in the evolu- tion of computer technology. It was the first step to the high-level languages in use today. Although few programmers use assembly language, virtually all machines provide one. They are used, if at all, for systems programs such as compilers and I/O routines. Appendix B provides a more detailed examination of assembly language. 13.6 RECOMMENDED READING The references cited in Chapter 12 are equally applicable to the material of this chapter. [BLAA97] contains a detailed discussion of instruction formats and addressing modes. In addition, the reader may wish to consult [FLYN85] for a discussion and analysis of instruc- tion set design issues, particularly those relating to formats. autoindexing base-register addressing direct addressing displacement addressing effective address immediate addressing indexing indirect addressing instruction format postindexing preindexing register addressing register indirect addressing relative addressing word 13.7 KEY TERMS, REVIEW QUESTIONS, AND PROBLEMS Key Terms 480 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS Problems 13.1 Given the following memory values and a one-address machine with an accumulator, what values do the following instructions load into the accumulator? • Word 20 contains 40. • Word 30 contains 50. • Word 40 contains 60. • Word 50 contains 70. a. LOAD IMMEDIATE 20 b. LOAD DIRECT 20 c. LOAD INDIRECT 20 d. LOAD IMMEDIATE 30 e. LOAD DIRECT 30 f. LOAD INDIRECT 30 13.2 Let the address stored in the program counter be designated by the symbol X1. The instruction stored in X1 has an address part (operand reference) X2. The operand needed to execute the instruction is stored in the memory word with address X3. An index register contains the value X4. What is the relationship between these various quantities if the addressing mode of the instruction is (a) direct; (b) indirect; (c) PC relative; (d) indexed? 13.3 An address field in an instruction contains decimal value 14. Where is the correspond- ing operand located for a. immediate addressing? b. direct addressing? c. indirect addressing? d. register addressing? e. register indirect addressing? 13.4 Consider a 16-bit processor in which the following appears in main memory, starting at location 200: 200 Load to AC Mode 201 500 202 Next instruction The first part of the first word indicates that this instruction loads a value into an ac- cumulator. The Mode field specifies an addressing mode and, if appropriate, indicates a source register; assume that when used, the source register is R1, which has a value of 400. There is also a base register that contains the value 100. The value of 500 in location 201 may be part of the address calculation. Assume that location 399 contains the value 999, location 400 contains the value 1000, and so on. Determine the effective address and the operand to be loaded for the following address modes: a. Direct b. Immediate c. Indirect d. PC relative e. Displacement f. Register g. Register indirect h. Autoindexing with increment, using R1 13.5 A PC-relative mode branch instruction is 3 bytes long. The address of the instruction, in decimal, is 256028. Determine the branch target address if the signed displacement in the instruction is -31. 13.6 A PC-relative mode branch instruction is stored in memory at address 62010. The branch is made to location 53010. The address field in the instruction is 10 bits long. What is the binary value in the instruction? 13.7 / KEY TERMS, REVIEW QUESTIONS, AND PROBLEMS 481 13.7 How many times does the processor need to refer to memory when it fetches and executes an indirect-address-mode instruction if the instruction is (a) a computation requiring a single operand; (b) a branch? 13.8 The IBM 370 does not provide indirect addressing. Assume that the address of an operand is in main memory. How would you access the operand? 13.9 In [COOK82], the author proposes that the PC-relative addressing modes be elimi- nated in favor of other modes, such as the use of a stack. What is the disadvantage of this proposal? 13.10 The x86 includes the following instruction: IMUL op1, op2, immediate This instruction multiplies op2, which may be either register or memory, by the imme- diate operand value, and places the result in op1, which must be a register. There is no other three-operand instruction of this sort in the instruction set. What is the possible use of such an instruction? (Hint: Consider indexing.) 13.11 Consider a processor that includes a base with indexing addressing mode. Suppose an instruction is encountered that employs this addressing mode and specifies a displace- ment of 1970, in decimal. Currently the base and index register contain the decimal numbers 48,022 and 8, respectively. What is the address of the operand? 13.12 Define: EA = (X)+ is the effective address equal to the contents of location X, with X incremented by one word length after the effective address is calculated; EA = -(X) is the effective address equal to the contents of location X, with X decremented by one word length before the effective address is calculated; EA = (X)- is the effec- tive address equal to the contents of location X, with X decremented by one word length after the effective address is calculated. Consider the following instructions, each in the format (Operation Source Operand, Destination Operand), with the result of the operation placed in the destination operand. a. OP X, (X) b. OP (X), (X)+ c. OP (X)+ , (X) d. OP - (X), (X) e. OP - (X), (X)+ f. OP (X)+ , (X)+ g. OP (X)- , (X) Using X as the stack pointer, which of these instructions can pop the top two elements from the stack, perform the designated operation (e.g., ADD source to destination and store in destination), and push the result back on the stack? For each such instruc- tion, does the stack grow toward memory location 0 or in the opposite direction? 13.13 Assume a stack-oriented processor that includes the stack operations PUSH and POP. Arithmetic operations automatically involve the top one or two stack elements. Begin with an empty stack. What stack elements remain after the following instructions are executed? PUSH 4 PUSH 7 PUSH 8 ADD PUSH 10 SUB MUL 13.14 Justify the assertion that a 32-bit instruction is probably much less than twice as useful as a 16-bit instruction. 13.15 Why was IBM’s decision to move from 36 bits to 32 bits per word wrenching, and to whom? 482 CHAPTER 13 / INSTRUCTION SETS: ADDRESSING MODES AND FORMATS 13.16 Assume an instruction set that uses a fixed 16-bit instruction length. Operand speci- fiers are 6 bits in length. There are K two-operand instructions and L zero-operand instructions. What is the maximum number of one-operand instructions that can be supported? 13.17 Design a variable-length opcode to allow all of the following to be encoded in a 36-bit instruction: • instructions with two 15-bit addresses and one 3-bit register number • instructions with one 15-bit address and one 3-bit register number • instructions with no addresses or registers 13.18 Consider the results of Problem 10.6. Assume that M is a 16-bit memory address and that X, Y, and Z are either 16-bit addresses or 4-bit register numbers. The one-address machine uses an accumulator, and the two- and three-address machines have 16 regis- ters and instructions operating on all combinations of memory locations and registers. Assuming 8-bit opcodes and instruction lengths that are multiples of 4 bits, how many bits does each machine need to compute X? 13.19 Is there any possible justification for an instruction with two opcodes? 13.20 The 16-bit Zilog Z8001 has the following general instruction format: 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 Mode Opcode w/b Operand 2 Operand 1 The mode field specifies how to locate the operands from the operand fields. The w/b field is used in certain instructions to specify whether the operands are bytes or 16-bit words. The operand 1 field may (depending on the mode field contents) specify one of 16 general-purpose registers. The operand 2 field may specify any general-purpose registers except register 0. When the operand 2 field is all zeros, each of the original opcodes takes on a new meaning. a. How many opcodes are provided on the Z8001? b. Suggest an efficient way to provide more opcodes and indicate the trade-off involved.